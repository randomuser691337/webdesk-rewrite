var windowHighestZIndex = 0;
console.log('<i> UI is here');
UI = {
    LLMName: "Chloe",
    userName: "User",
    create: function (eltype, parent, classname) {
        var el = document.createElement(eltype);
        if (classname) el.classList = classname;
        if (parent) parent.appendChild(el);
        return el;
    },
    mousedown: function (element, duration = 100) {
        // Generated by Google AI overview
        const mouseDownEvent = new MouseEvent('mousedown', {
            view: window,
            bubbles: true,
            cancelable: true,
            button: 0
        });

        element.dispatchEvent(mouseDownEvent);

        setTimeout(() => {
            const mouseUpEvent = new MouseEvent('mouseup', {
                view: window,
                bubbles: true,
                cancelable: true,
                button: 0
            });

            element.dispatchEvent(mouseUpEvent);
        }, duration);
    },
    menuSlide: function (element, options) {
        /* 
            ORIGINAL ANIMATION GENERATED BY AI, modified by me
            options variable:
            - true: show element via slide
            - false: hide element via slide
            - "setup": adds proper stylings to element, default hidden
            - "stop": removes proper stylings from element 
            - undefined: toggle
        */

        if (options === true) {
            element.style.transform = "translateX(0%)";
            element.style.opacity = "1";
        } else if (options === "setup") {
            element.style.transition = "transform 0.25s ease, opacity 0.25s ease";
            element.style.transform = "translateX(-100%)";
            element.style.opacity = "0";
        } else if (options === "stop") {
            element.style.transition = "";
            element.style.transform = "";
            element.style.opacity = "";
        } else if (options === false) {
            element.style.transform = "translateX(-100%)";
            element.style.opacity = "0";
        } else {
            if (element.style.transform === "translateX(0%)") {
                element.style.transform = "translateX(-100%)";
                element.style.opacity = "0";
            } else {
                element.style.transform = "translateX(0%)";
                element.style.opacity = "1";
            }
        }
    },
    button: function (parent, text, classname) {
        var btn = this.create("button", parent, classname + " webdesk-ui-styling noselect");
        btn.setAttribute("role", "button");
        btn.tabIndex = 0;
        btn.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                btn.click();
            }
        });

        if (typeof classname === "string" && classname.includes("ui-big-btn")) {
            const txt = this.create("div", btn, "ui-big-btn-filler noselect");
            txt.textContent = text;
            btn.Filler = txt;
        } else if (typeof classname === "string" && classname.includes("ui-small-btn")) {
            const txt = this.create("div", btn, "ui-small-btn-filler noselect");
            txt.textContent = text;
            btn.Filler = txt;
        } else if (typeof classname === "string" && classname.includes("ui-med-btn")) {
            const txt = this.create("div", btn, "ui-med-btn-filler noselect");
            txt.textContent = text;
            btn.Filler = txt;
        } else {
            btn.textContent = text;
        }

        if (btn.Filler) {
            const b = btn.Filler;
            if (sys.lowgfxMode === true) {
                b.style.transition = "0.04s ease-in-out";
                b.onmouseenter = (e) => {
                    e.target.style.background = "rgba(var(--ui-accent), 0.25)";
                };

                b.onmouseleave = (e) => {
                    e.target.style.background = "rgba(var(--ui-accent), 0.2)";
                };

                b.onmousedown = (e) => {
                    e.target.style.background = "rgba(var(--ui-accent), 0.3)";
                };
            } else {
                b.onmouseleave = (e) => {
                    e.target.style.background = "rgba(var(--ui-accent), 0.2)";
                };

                b.addEventListener("mousemove", (e) => {
                    const { left, top } = e.target.getBoundingClientRect();
                    const x = e.clientX - left;
                    const y = e.clientY - top;
                    const accent = 'rgba(var(--ui-accent),';
                    const bg =
                        e.buttons === 1
                            ? `radial-gradient(circle at ${x}px ${y}px, ${accent}0.4), ${accent}0.2)`
                            : `radial-gradient(circle at ${x}px ${y}px, ${accent}0.3), ${accent}0.2)`;
                    e.target.style.background = bg;
                });

                b.addEventListener("mousedown", (e) => {
                    const rect = e.target.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    e.target.style.background = `radial-gradient(circle at ${x}px ${y}px, rgba(var(--ui-accent), 0.4), rgba(var(--ui-accent), 0.25))`;
                });
            }
        }

        btn.dropBtnDecor = function () {
            let elappend = btn;
            if (btn.Filler) {
                elappend = btn.Filler;
            }

            btn.style.setProperty("transform", "scale(1.0)", "important");
            const el = UI.create('span', elappend)
            el.innerText = ">";
            el.style = "display: inline-block; transform: rotate(90deg); margin-left: 4px;";
        };

        return btn;
    },
    input: function (parent, placeholder, classname, type) {
        var input = this.create("input", parent, classname);
        input.placeholder = placeholder;
        if (type) {
            input.type = type;
        }
        return input;
    },
    switch: {
        // Created the create function myself, toggle and checked were auto generated by Copilot and modified by me
        create: function (parent, toggled, disableBuiltInToggle) {
            const UISwitch = UI.create('div', parent, 'ui-switch');
            const switchOn = UI.create('div', UISwitch, 'ui-switch-knob');
            if (toggled === true) {
                UISwitch.classList.remove('ui-switch-disabled');
                UISwitch.classList.remove('ui-switch-disabled-flag');
                UISwitch.classList.add('ui-switch-enabled');
                UISwitch.classList.add('ui-switch-enabled-flag');
            } else {
                UISwitch.classList.remove('ui-switch-enabled');
                UISwitch.classList.remove('ui-switch-enabled-flag');
                UISwitch.classList.add('ui-switch-disabled');
                UISwitch.classList.add('ui-switch-disabled-flag');
            }

            if (disableBuiltInToggle !== true) {
                UISwitch.addEventListener('click', function () {
                    UI.switch.toggle(UISwitch);
                });
            }

            return UISwitch;
        },
        toggle: function (element) {
            if (element.classList.contains('ui-switch-enabled-flag')) {
                return this.uncheck(element);
            } else {
                return this.check(element);
            }
        },
        check: function (element) {
            // 15px -> 30px -> 15px animation fixed by AI
            element.classList.remove('ui-switch-disabled-flag');
            element.classList.add('ui-switch-enabled-flag');
            Array.from(element.children).forEach((child) => {
                child.style.width = "30px";
                setTimeout(function () {
                    child.style.width = "15px";
                    element.classList.remove('ui-switch-disabled');
                    element.classList.add('ui-switch-enabled');
                }, 100);
            });
            return true;
        },
        uncheck: function (element) {
            // 15px -> 30px -> 15px animation fixed by AI
            element.classList.remove('ui-switch-enabled-flag');
            element.classList.add('ui-switch-disabled-flag');
            Array.from(element.children).forEach((child) => {
                child.style.width = "30px";
                setTimeout(function () {
                    child.style.width = "15px";
                    element.classList.remove('ui-switch-enabled');
                    element.classList.add('ui-switch-disabled');
                }, 100);
            });
            return false;
        },
        checked: function (element) {
            return element.classList.contains('ui-switch-enabled-flag');
        }
    },
    notif: async function (title, body, icon) {
        const notif = UI.create('div', UI.System.SystemMenus.notifArea, 'wd-notif');
        const closeBtn = UI.button(notif, 'x', 'wd-notif-close-button');
        closeBtn.addEventListener('click', () => {
            UI.remove(notif);
        });
        const wdNotifToast = UI.create('div', notif, 'wd-notif-toast');
        let iconImg;
        if (icon) {
            iconImg = UI.img(wdNotifToast, icon, 'wd-notif-img');
        } else {
            iconImg = UI.img(wdNotifToast, '/system/lib/img/notification-toast.svg', 'wd-notif-img');
        }

        const contents = UI.create('div', notif, 'wd-notif-contents');
        const titleDiv = UI.create('div', contents, 'wd-notif-title');
        const name = UI.create('div', titleDiv, 'wd-notif-title-name bold');
        const time = UI.create('div', titleDiv, 'wd-notif-title-time smalltxt');
        name.innerText = title;
        time.innerText = UI.getDate();
        const mainDiv = UI.create('div', contents);
        if (body) {
            mainDiv.innerText = body;
        }

        function removeNotif() {
            notif.remove();
        }

        return notif, { notif, name, time, mainDiv, titleDiv, iconImg, contents, wdNotifToast, removeNotif }
    },
    getDate: function (type) {
        const now = new Date();
        if (type === "military") {
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        } else {
            let hours = now.getHours();
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12;
            return `${hours}:${minutes} ${ampm}`;
        }
    },
    sendToLLM: async function (messages, userContent, token, temp, top_p) {
        try {
            const result = await sys.LLM.send(messages, userContent, token, temp, top_p);
            if (result && result.responseMessage) {
                return result.responseMessage;
            } else {
                throw new Error("<!> No response from LLM");
            }
        } catch (error) {
            console.error("<!> Error sending to LLM:", error);
            throw new Error("Error sending to LLM");
        }
    },
    stopLLMGeneration: async function () {
        try {
            const result = await sys.LLM.stopGenerating();
            return true;
        } catch (error) {
            console.error("<!> Error sending to LLM:", error);
            throw new Error("Error sending to LLM");
        }
    },
    text: function (parent, text, classname) {
        var txt = this.create("p", parent, classname);
        txt.textContent = text;
        return txt;
    },
    window: function (title, module, menuBarItems, icon) {
        const win = this.create("div", document.body, "window");
        const header = this.create("div", win, "window-header window-draggable");
        const headerbtns = this.create("div", header, "window-header-nav");
        const headertxt = this.create("div", header, "window-header-text");
        const content = this.create("div", win, "window-content");
        let winFinal;
        headertxt.textContent = title;
        windowHighestZIndex += 1;
        win.style.zIndex = windowHighestZIndex;

        const closeBtn = this.button(headerbtns, '', "window-btn close-btn");
        const minBtn = this.button(headerbtns, '', "window-btn min-btn");
        const maxBtn = this.button(headerbtns, '', "window-btn max-btn");

        const prereq = "minimized-" + title;
        let winMinimized = prereq.replace(' ', '');

        // Window dragging code written by AI, I'd rewrite it but there's nothing to rewrite

        let offsetX = 0, offsetY = 0;
        let isDragging = false;

        const onPointerMove = (e) => {
            if (!isDragging) return;
            win.style.position = "absolute";
            win.style.left = `${e.clientX - offsetX}px`;
            win.style.top = `${e.clientY - offsetY}px`;
        };

        const onPointerUp = () => {
            isDragging = false;
            window.removeEventListener("pointermove", onPointerMove);
            window.removeEventListener("pointerup", onPointerUp);
        };

        const setupDraggable = (el) => {
            el.style.touchAction = "none";
            el.addEventListener("pointerdown", (e) => {
                const rect = win.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                isDragging = true;

                window.addEventListener("pointermove", onPointerMove);
                window.addEventListener("pointerup", onPointerUp);
            });
        };

        const updateWindow = () => {
            const draggables = win.querySelectorAll('.window-draggable');
            draggables.forEach(setupDraggable);
            win.style.left = `${(window.innerWidth - win.offsetWidth) / 2}px`;
            win.style.top = `${(window.innerHeight - win.offsetHeight) / 2}px`;
        };

        updateWindow();

        // closeWin logic debugged by AI
        function closeWin() {
            win.remove();
            UI.remove(iconDiv);
            if (UI.previousFocusedWindow && document.body.contains(UI.previousFocusedWindow.win)) {
                UI.previousFocusedWindow.focusWindow();
                UI.focusedWindow = UI.previousFocusedWindow;
                UI.previousFocusedWindow = undefined;
            } else {
                const windows = Array.from(document.querySelectorAll('.window'));
                if (windows.length > 0) {
                    const lastWinEl = windows[windows.length - 1];
                    const lastWinObj = [UI.focusedWindow, UI.previousFocusedWindow]
                        .find(w => w && w.win === lastWinEl);
                    if (lastWinObj) lastWinObj.focusWindow();
                } else {
                    UI.focusedWindow = undefined;
                    UI.System.SystemMenus.MenuBarActions.innerHTML = `<button class="med menuBar-btn">Desktop</button>`;
                }
            }
        }

        closeBtn.addEventListener("click", () => {
            if (module) {
                console.log(module);
                if (typeof module.close === 'function') {
                    module.close();
                }
            } else {
                closeWin();
            }
        });

        minBtn.addEventListener("click", () => {
            minimizeToggle();
        });

        // updateMenuBarItems was written by me

        function updateMenuBarItems(items) {
            if (items) {
                menuBarItems = items;
            }
            if (parseInt(win.style.zIndex) == windowHighestZIndex) {
                UI.System.SystemMenus.MenuBarActions.innerHTML = "";
                const btn = UI.button(UI.System.SystemMenus.MenuBarActions, title, 'med menuBar-btn');
                btn.addEventListener('mousedown', function () {
                    const rect = btn.getBoundingClientRect();
                    const event = {
                        clientX: Math.floor(rect.left),
                        clientY: Math.floor(rect.bottom) + 6
                    };

                    const menu = UI.rightClickMenu(event);
                    menu.classList.add('menuBar-Menu');
                    menu.style.width = `${Math.floor(rect.width) - 10}px`;
                    const menuBarItems2 = [{
                        name: "Quit", action: function () {
                            closeBtn.click();
                        }
                    }];

                    menuBarItems2.forEach(function (child) {
                        const btn2 = UI.button(menu, child.name, 'ui-menubar-btn wide');
                        let alreadyFired = false;
                        btn2.addEventListener('click', function () {
                            if (alreadyFired === false) {
                                child.action();
                                alreadyFired = true;
                            }
                        });
                        btn2.addEventListener('mouseup', function () {
                            if (alreadyFired === false) {
                                child.action();
                                alreadyFired = true;
                            }
                        });
                    });
                });

                if (menuBarItems) {
                    menuBarItems.forEach(function (menuBarItem) {
                        const btn = UI.button(UI.System.SystemMenus.MenuBarActions, menuBarItem.title, 'med menuBar-btn');

                        function trigger() {
                            const rect = btn.getBoundingClientRect();
                            const event = {
                                clientX: Math.floor(rect.left),
                                clientY: Math.floor(rect.bottom)
                            };

                            const menu = UI.rightClickMenu(event);
                            menu.classList.add('menuBar-Menu');
                            menu.style.width = `${Math.floor(rect.width) - 10}px`;
                            menuBarItem.children.forEach(function (child) {
                                const btn2 = UI.button(menu, child.name, 'ui-small-btn wide');
                                btn2.addEventListener('click', child.action);
                                btn2.addEventListener('mouseup', child.action);
                            });
                        }

                        btn.addEventListener('mousedown', trigger);
                    });
                }
            }
        }

        // focusWindow UI logic debugged by AI
        function focusWindow() {
            if (winMinimized === true) {
                minimizeToggle();
            }
            if (parseInt(win.style.zIndex) !== windowHighestZIndex) {
                windowHighestZIndex += 1;
                win.style.zIndex = windowHighestZIndex;
            }

            if (UI.focusedWindow && UI.focusedWindow !== winFinal) {
                UI.previousFocusedWindow = UI.focusedWindow;
            }

            UI.focusedWindow = winFinal;
            updateMenuBarItems();
        }

        const iconDiv = UI.button(UI.System.SystemMenus.taskbarWindows, '', 'ui-dock-btn');

        if (icon) {
            UI.img(iconDiv, icon, 'dock-icon');
        } else {
            // Canvas code fully generated by AI, slightly modified by me
            const canvas = UI.create('canvas');
            canvas.width = 40 * window.devicePixelRatio;
            canvas.height = 40 * window.devicePixelRatio;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = `rgba(${UI.readvar('ui-accent')}, 1)`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = 20 * window.devicePixelRatio + 'px "Poppins"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(title.charAt(0).toUpperCase(), canvas.width / 2, canvas.height / 2);
            UI.img(iconDiv, canvas.toDataURL(), 'dock-icon');
        }

        // minimizeToggle debugged by AI


        function minimizeToggle() {
            if (winMinimized === true) {
                win.style.transform = '';
                win.style.opacity = '';
                win.dataset.minimized = 'false';
                winMinimized = false;
            } else {
                if (winMinimized === true) {
                    win.dataset.minimized = 'false';
                    win.classList.remove(winMinimized);
                    return;
                }

                winMinimized = true;

                const rect = iconDiv.getBoundingClientRect();
                const winRect = win.getBoundingClientRect();
                const dx = rect.x - winRect.x - winRect.width / 2 + 20;
                const dy = rect.y - winRect.y - winRect.height;

                win.style.transition = 'transform var(--anim-speed-medium) ease, opacity var(--anim-speed-medium) ease';
                win.style.transformOrigin = 'bottom center';
                win.style.transform = `translate(${dx}px, ${dy}px) scale(0)`;
                win.style.opacity = '0.5';

                win.addEventListener('transitionend', function handler() {
                    win.removeEventListener('transitionend', handler);
                    win.dataset.minimized = 'true';
                });
            }
        }

        iconDiv.style.marginLeft = "4px";

        iconDiv.addEventListener('click', function () {
            focusWindow();
        });

        winFinal = { win, header, content, headertxt, headerbtns, ID: title + windowHighestZIndex, title, buttons: { closeBtn, minBtn, maxBtn, container: headerbtns, taskbarBtn: iconDiv }, updateWindow, focusWindow, updateMenuBarItems, closeWin, minimizeToggle }

        win.addEventListener("mousedown", () => {
            focusWindow(true);
        });

        UI.mousedown(win);
        win.dataset.name = title;
        return winFinal;
    },
    changeimg: async function (img, path) {
        const blob = await fs.read(path);
        if (blob instanceof Blob) {
            img.src = URL.createObjectURL(blob);
        } else {
            console.log(`<!> ` + path + ` is not an image decodable by WebDesk's UI. Trying URL...`);
            img.src = path;
        }
    },
    img: async function (parent, path, classname) {
        const img = this.create('img', parent, classname);
        await UI.changeimg(img, path);
        return img;
    },
    changevar: function (varname, value) {
        document.documentElement.style.setProperty(`--${varname}`, value);
    },
    readvar: function (varname) {
        return getComputedStyle(document.documentElement).getPropertyValue(`--${varname}`).trim();
    },
    remove: function (element) {
        if (document.body.contains(element)) {
            element.remove();
        }
    },
    truncate: function (text, maxLength, ellipsis = true) {
        if (text.length <= maxLength) return text;
        if (ellipsis) {
            return text.slice(0, maxLength - 3) + '...';
        } else {
            return text.slice(0, maxLength);
        }
    },
    rightClickMenu: function (event) {
        const menu = this.create('div', document.body, 'right-click-menu');
        menu.style.left = `${event.clientX}px`;
        menu.style.top = `${event.clientY}px`;
        menu.style.width = "140px"; // fuck it
        // protection

        const rect = menu.getBoundingClientRect();
        console.log(rect);
        console.log(document.documentElement.clientWidth);
        console.log(event.clientX + rect.width);
        if (document.documentElement.clientWidth < event.clientX + rect.width) {
            menu.style.right = `4px`;
            menu.style.left = `auto`;
        } else {
            console.log('<i> menu doesnt need repos');
        }

        setTimeout(function () {
            document.addEventListener('click', () => {
                UI.remove(menu);
            }, { once: true });
        }, 250);

        return menu;
    },
    line: function (parent) {
        UI.create('div', parent, 'group-line');
    },
    leftRightLayout: function (parent) {
        const container = this.create('div', parent, 'flexbox');
        const left = this.create('div', container, 'flexbox-left');
        const right = this.create('div', container, 'flexbox-right');
        return { left, right };
    },
    snack: function (message, duration = 5000) {
        const snackbar = this.create('div', document.body, 'snack');
        snackbar.textContent = message;
        setTimeout(() => {
            UI.remove(snackbar);
        }, duration);
        return snackbar;
    },
    focusedWindow: undefined,
    previousFocusedWindow: undefined,
    System: {
        SystemMenus: {
            taskbar: undefined,
            menubar: undefined,
        },
        launchApp: async function (path) {
            const code = await fs.read(path);

        },
        darkMode: function () {
            UI.changevar('ui-primary', '40, 40, 40');
            UI.changevar('ui-secondary', '50, 50, 50');
            UI.changevar('ui-tertiary', '60, 60, 60');
            UI.changevar('text', '#fff');
        },
        lightMode: function () {
            UI.changevar('ui-primary', '255, 255, 255');
            UI.changevar('ui-secondary', '240, 240, 240');
            UI.changevar('ui-tertiary', '225, 225, 225');
            UI.changevar('text', '#000');
        },
        llmRing: function (state) {
            const ring = document.querySelector('.ring');
            if (ring) {
                if (state === 'waiting') {
                    ring.style.setProperty('--color-start', '#08f');
                    ring.style.setProperty('--color-end', '#00f');
                    ring.style.setProperty('--speed', '4s');
                } else if (state === 'thinking') {
                    ring.style.setProperty('--color-start', '#fe0');
                    ring.style.setProperty('--color-end', '#fb0');
                    ring.style.setProperty('--speed', '2.5s');
                } else if (state === 'disabled') {
                    ring.style.setProperty('--color-start', '#999');
                    ring.style.setProperty('--color-end', '#999');
                    ring.style.setProperty('--speed', '2.5s');
                    sys.LLMLoaded = false;
                } else if (state === "loading") {
                    ring.style.setProperty('--color-start', '#c9f');
                    ring.style.setProperty('--color-end', '#88f');
                    ring.style.setProperty('--speed', '1s');
                } else if (state === 'error') {
                    ring.style.setProperty('--color-start', '#f00');
                    ring.style.setProperty('--color-end', '#f00');
                    setTimeout(() => {
                        ring.style.setProperty('--color-start', 'rgb(0, 0, 0, 0)');
                        ring.style.setProperty('--color-end', 'rgb(0, 0, 0, 0)');
                        setTimeout(() => {
                            ring.style.setProperty('--color-start', '#f00');
                            ring.style.setProperty('--color-end', '#f00');
                            setTimeout(() => {
                                UI.System.llmRing('waiting');
                            }, 200);
                        }, 170);
                    }, 200);
                }
            }
        },
        lowgfxMode: function (lowgfx) {
            if (lowgfx === true) {
                UI.changevar('main-ui-blur', '0px');
                UI.changevar('ui-transparency', '1');
                UI.changevar('ui-transparency-secondary', '1');
                UI.changevar('ui-transparency-tertiary', '1');
                UI.changevar('big-shadow', 'none');
                UI.changevar('small-shadow', 'none');
                sys.lowgfxMode = true;
            } else {
                UI.changevar('main-ui-blur', '8px');
                UI.changevar('ui-transparency', '0.9');
                UI.changevar('ui-transparency-secondary', '0.5');
                UI.changevar('ui-transparency-tertiary', '0.7');
                UI.changevar('big-shadow', '0 6px 12px rgba(0, 0, 0, 0.2)')
                UI.changevar('small-shadow', '1px 0 8px rgba(0, 0, 0, 0.12)');
                sys.lowgfxMode = false;
            }
        },
        generateBlobWallpaper: function () {
            // ENTIRELY AI GENERATED - slightly modified by me for performance
            const code = `
            self.onmessage = async (e) => {
            const { width, height, textColor, accentColor } = e.data;
            const canvas = new OffscreenCanvas(width, height);
            const ctx = canvas.getContext('2d');

            const colors = [];
            function selectRandomColor() {
                const predefinedColors = [0, 30, 60, 210, 240, 270, 300];
                let hue;
                do {
                hue = predefinedColors[Math.floor(Math.random() * predefinedColors.length)];
                } while (colors.some(c => c.startsWith(\`hsl(\${hue},\`)));
                return hue;
            }

            while (colors.length < 5) {
                const hue = selectRandomColor();
                const sat = 100;
                const light = textColor === "#fff" ? 35 : 85;
                colors.push(\`hsl(\${hue},\${sat}%,\${light}%)\`);
            }

            colors[Math.floor(Math.random() * colors.length)] = \`rgb(\${accentColor})\`;

            ctx.fillStyle = colors[0];
            ctx.fillRect(0, 0, width, height);

            for (let i = 1; i < colors.length; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const maxR = Math.max(width, height);
                const radius = maxR * (0.4 + Math.random() * 0.6);

                const grad = ctx.createRadialGradient(x, y, 0, x, y, radius);
                grad.addColorStop(0, colors[i]);
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, width, height);
            }

            ctx.globalAlpha = 0.5;
            for (let j = 0; j < 4; j++) {
                ctx.drawImage(canvas, Math.random() * 10 - 5, Math.random() * 10 - 5);
            }
            ctx.globalAlpha = 1;

            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const n = (Math.random() - 0.5) * 4;
                data[i] += n;
                data[i + 1] += n;
                data[i + 2] += n;
            }
            ctx.putImageData(imageData, 0, 0);

            const blob = await canvas.convertToBlob({ type: 'image/png' });
            self.postMessage(blob);
            };
            `;

            const width = window.screen.width * window.devicePixelRatio;
            const height = window.screen.height * window.devicePixelRatio;
            const textColor = UI.readvar('text');
            const accentColor = UI.readvar('ui-accent');

            const blob = new Blob([code], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            const worker = new Worker(url);

            worker.onmessage = (e) => {
                const blob = e.data;
                const imgUrl = URL.createObjectURL(blob);

                const img = new Image();
                img.onload = async function () {
                    (async function () { document.body.style.backgroundImage = `url(${imgUrl})`; })();
                    setTimeout(() => {
                        URL.revokeObjectURL(imgUrl);
                        worker.terminate();
                        URL.revokeObjectURL(url);
                    }, 1000);
                };
                img.src = imgUrl;
            };

            worker.postMessage({ width, height, textColor, accentColor });
        },
        fullscreenToggle: function (element) {
            // 100% AI lol
            if (!document.fullscreenElement) {
                // If not in fullscreen, request it
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.webkitRequestFullscreen) { // Safari
                    element.webkitRequestFullscreen();
                } else if (element.msRequestFullscreen) { // IE11
                    element.msRequestFullscreen();
                }
            } else {
                // If in fullscreen, exit it
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { // Safari
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { // IE11
                    document.msExitFullscreen();
                }
            }
        },
        GPUTest: function () {
            // ENTIRELY generated by ChatGPT
            function createProgram(gl, vsSource, fsSource) {
                function compile(type, source) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        throw new Error(gl.getShaderInfoLog(shader));
                    }
                    return shader;
                }

                const vs = compile(gl.VERTEX_SHADER, vsSource);
                const fs = compile(gl.FRAGMENT_SHADER, fsSource);

                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error(gl.getProgramInfoLog(program));
                }
                return program;
            }

            function quickGpuBenchmark(gl) {
                const vsSource = `
    attribute vec2 aPos;
    void main() {
      gl_Position = vec4(aPos, 0.0, 1.0);
    }
  `;
                const fsSource = `
    void main() {
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
  `;
                const program = createProgram(gl, vsSource, fsSource);
                gl.useProgram(program);

                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array([-1, -1, 1, -1, 0, 1]),
                    gl.STATIC_DRAW
                );

                const aPosLoc = gl.getAttribLocation(program, "aPos");
                gl.enableVertexAttribArray(aPosLoc);
                gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);

                const start = performance.now();
                const iterations = 200;
                for (let i = 0; i < iterations; i++) {
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLES, 0, 3);
                }
                const end = performance.now();

                return (end - start) / iterations;
            }
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl");
            if (!gl) return { error: "WebGL not supported" };

            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            const vendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "Unknown";
            const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Unknown";

            const perfScore = quickGpuBenchmark(gl);
            return { vendor, renderer, perfScore };
        }
    }
}