<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebDesk 0.3.3</title>
</head>

<body>
    <script>
        var fs;
        var set;

        var UI = {
            create: function (eltype, parent, classname) {
                var el = document.createElement(eltype);
                if (classname) el.classList = classname;
                if (parent) parent.appendChild(el);
                return el;
            },
            remove: function (element) {
                element.remove();
            },
            text: function (parent, text, classname) {
                var txt = this.create("p", parent, classname);
                txt.textContent = text;
                return txt;
            },
        }

        function gen(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        var core = {
            latestVersion: '0.3.3',
            lowgfxMode: false,
            incrementTask: 0,
            tasks: [],
            onTaskStart: [],
            onTaskClosed: [],
            async loadJS(path) {
                console.log('<i> Initializing ' + path)
                const data = await fs.read(path);
                if (!data) {
                    console.error(`<!> ${path} not found or not readable.`);
                    return;
                }
                var script = document.createElement('script');
                script.textContent = data;
                document.head.appendChild(script);
            },
            async loadCSS(path) {
                console.log('<i> Loading CSS: ' + path)
                const data = await fs.read(path);
                if (!data) {
                    console.error(`<!> ${path} not found or not readable.`);
                    return;
                }
                var script = document.createElement('style');
                script.textContent = data;
                document.head.appendChild(script);
            },
            async loadModule(code2) {
                const id = this.incrementTask++;
                const code = `export var id = ${id};\n` + code2;
                const blob = new Blob([code], { type: "application/javascript" });
                const url = URL.createObjectURL(blob);
                const mod = await import(url);

                const task = { name: mod.name || 'Unnamed Module', id, task: mod };
                this.tasks.push(task);
                this.onTaskStart.forEach(cb => cb.callback(task));

                URL.revokeObjectURL(url);
                return mod;
            },
            async removeModule(id) {
                const index = this.tasks.findIndex(t => t.id === id);
                if (index !== -1) {
                    this.tasks.splice(index, 1);
                    this.onTaskClosed.forEach(cb => cb.callback(id));
                }
            }
        }

        async function boot() {
            const bootloader = document.createElement('script');
            bootloader.type = "module";
            bootloader.textContent = `
            import { unzipSync } from "https://cdn.jsdelivr.net/npm/fflate@0.7.4/esm/browser.js";
            var div = UI.create('div', document.body);
            async function extractZipToOPFS(zipFile, div) {
                const txt = UI.text(div, 'Copying files...');

                console.log('FORCE UPDATE ENABLED. TURN OFF BEFORE PRODUCTION');
                const buffer = new Uint8Array(await zipFile.arrayBuffer());
                const files = unzipSync(buffer);

                for (const name in files) {
                    const fileData = files[name];
                    // console.log(fileData);

                    // Skip directories (either ends with '/' or is zero-length and has no extension)
                    if (name.endsWith('/') || name.endsWith('.DS_Store') || (fileData.length === 0 && !name.includes('.'))) continue;

                    function skip() {
                        return;
                    }

                    try {
                        txt.textContent = 'Copying: ' + name;

                        const filetype = name.match(/\.(png|jpg|jpeg|gif|webp|bmp|tiff|mp3|wav|flac|aac|ogg|m4a|mp4|webm|avi|mov|mkv|pdf|docx?|xlsx?|pptx?|zip|rar|7z|tar|gz|woff2?|ttf|otf)$/i) ? "blob" : "text";
                        let content;
                        if (filetype === "blob") {
                            content = fileData;
                        } else {
                            content = new TextDecoder().decode(fileData);
                        }
                        // console.log(name, fileData);
                        await fs.write('/' + name, content, filetype);
                        // console.log(fileData);
                        if (name.startsWith('apps/') && name.endsWith('index.js')) {
                            const parts = name.split('/');
                            let lastdir = parts[parts.length - 2];
                            lastdir = lastdir.replace('.app', '');
                            await fs.write('/system/apps/Desktop.app/Items/' + lastdir, '/' + name, filetype);
                        }
                    } catch (error) {
                        txt.textContent = 'Error copying: ' + name + ' - ' + error;
                        const skip = UI.create('button', txt);
                        skip.textContent = 'Skip';
                        skip.addEventListener('click', () => {
                            txt.textContent = 'Skipping: ' + name;
                            skip();
                        });
                    }
                }

                txt.textContent = 'Setting up...';

                await set.write('version', core.latestVersion);

                txt.textContent = 'Starting WebDesk...';

                console.log("ZIP extracted to OPFS. Handing control to init.js.");
                core.loadJS('/system/init.js');
                UI.remove(div);
            }

            (async () => {
    async function update() {
        try {
            UI.text(div, 'WebDesk 0.3.3 // dbh_ra9');
            const response = await fetch('desk.zip', { cache: 'no-store' });
            if (!response.ok) {
                throw new Error('<!> Failed to fetch zip: ' + response.statusText);
            }

            console.log('Response Status:', response.status);
            console.log('Content-Type:', response.headers.get('content-type'));
            const contentLength = response.headers.get('content-length');
            const totalSize = contentLength ? parseInt(contentLength, 10) : 0;
            let loadedSize = 0;

            const reader = response.body.getReader();
            const chunks = [];
            const progressEl = UI.text(div, '');
            progressEl.textContent = "Download progress: 0%";
            div.appendChild(progressEl);

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
                loadedSize += value.length;
                if (totalSize) {
                    const percent = Math.floor((loadedSize / totalSize) * 100);
                    progressEl.textContent = 'Download progress: ' + percent + '%';
                }
            }
            const zipBlob = new Blob(chunks);
            await extractZipToOPFS(zipBlob, div);
        } catch (err) {
            console.error('Error extracting desk.zip:', err);
        }
    }

    // FORCEUPDATE FLAG
    // FORCEUPDATE FLAG

    const FORCEUPDATE = true;

    // FORCEUPDATE FLAG
    // FORCEUPDATE FLAG

    UI.text(div, 'Enter passcode');
    const input = UI.create('input', div);
    input.placeholder = "Passcode";
    const btn = UI.create('button', div);
    btn.innerText = "Unlock";
    btn.addEventListener('click', async function () {
        const test = await fs.passcode(input.value);
        console.log(test);
        if (FORCEUPDATE === false) {
            console.log('<i> FORCEUPDATE flag false, checking for updates');
            const currentRes = await set.read('version');
            if (core.latestVersion === currentRes) {
                console.log('<i> Up to date: ' + currentRes);
                core.loadJS('/system/init.js');
            } else {
                await update();
            }
        } else {
            console.log('<i> FORCEUPDATE enabled, DISABLE BEFORE PRODUCTION');
            await update();
        }
    });
})();`;
            document.body.appendChild(bootloader);
        }
    </script>
</body>
<script>
    var sys = {
        socket: undefined,
        config: undefined,
        LLM: undefined,
        LLMLoaded: false,
        OPFSSupported: false,
    };

    var webid = {
        priv: 1,
        userid: undefined,
    }
    let forceIDB = false;
    (async () => {
        // Debugged by AI
        if ('storage' in navigator && 'getDirectory' in navigator.storage) {
            try {
                const testWorker = new Worker('./wfs.js');
                var currentopsTest = []
                const TestFS = {
                    read: function (path) {
                        const uID = gen(0, 9999);
                        return new Promise((resolve, reject) => {
                            currentopsTest.push({ uID, resolve, reject });
                            testWorker.postMessage({ optype: "read", uID, data: path });
                        });
                    },
                    write: function (path, data, filetype = "text") {
                        const uID = gen(0, 9999);
                        return new Promise((resolve, reject) => {
                            currentopsTest.push({ uID, resolve, reject });
                            testWorker.postMessage({ optype: "write", uID, data: path, data2: data, filetype: filetype });
                        });
                    },
                    rm: function (path, recursive = false) {
                        const uID = gen(0, 9999);
                        return new Promise((resolve, reject) => {
                            currentopsTest.push({ uID, resolve, reject });
                            testWorker.postMessage({ optype: "rm", uID, data: path, data2: recursive });
                        });
                    },
                }

                testWorker.addEventListener("message", (msg) => {
                    if (msg.data.optype === "ready") {
                        console.log('<i> Loaded OPFS support tester');
                    }
                    currentopsTest.filter(op => {
                        if (op.uID === msg.data.uID) {
                            op.resolve(msg.data.data);
                            return false;
                        }
                        return true;
                    });
                });

                await TestFS.write('/system/OPFSSupported', JSON.stringify({ testString: "true" }));
                const testRaw = await TestFS.read('/system/OPFSSupported');
                let test;
                try {
                    test = JSON.parse(testRaw);
                } catch (e) {
                    test = null;
                }
                TestFS.rm('/system/OPFSSupported');
                if (test && test.testString === "true") {
                    console.log('<i> Browser passed OPFS test!');
                    sys.OPFSSupported = true;
                }
                testWorker.terminate();
                const script = document.createElement('script');
                script.src = sys.OPFSSupported && !forceIDB ? "./fs.js" : "./oldfs.js";
                document.body.appendChild(script);
            } catch (error) {
                console.log(error);
                sys.OPFSSupported = false;
                const script = document.createElement('script');
                script.src = "./oldfs.js";
                document.body.appendChild(script);
            }
        } else {
            console.log(`<!> Browser doesn't report support!`);
            const script = document.createElement('script');
            script.src = "./oldfs.js";
            document.body.appendChild(script);
            sys.OPFSSupported = false;
        }
        console.log("OPFS supported?", sys.OPFSSupported);
    })();
</script>
<!--<script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";
    console.log('Let there be LLMs');
    const initProgressCallback = (progress) => {
        console.log("Model loading progress:", progress);
    };

    // Using CreateMLCEngine
    const engine = await CreateMLCEngine("TinyLlama-1.1B-Chat-v1.0-q4f16_1-MLC", { initProgressCallback });

    // Direct instantiation
    const engineInstance = new MLCEngine({ initProgressCallback });
    await engineInstance.reload("TinyLlama-1.1B-Chat-v1.0-q4f16_1-MLC");
</script>-->

</html>